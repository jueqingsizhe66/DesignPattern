## 单例模式

单例模式最典型的特征是构造器私有化，可以进一步查看[彻底玩转单例模式][1]
要求线程安全、内存耗费较少

推荐

1. 枚举单例
2. 静态代码类单例
3. 双重检查(懒汉式升级版， 懒汉式不用！)
3. 饿汉式(JDK Runtime 较耗内存)--- **直接创建私有对象，类加载的时候，就创建了对象**
4. 饿汉式静态代码段

## 不再new

而是通过getInstance的方式 

## 使用场景：

1. 数据源
2. session工厂
3. 经常使用的对象(创建+销毁)
4. 工具类等
5. 重量级对象

## violate

volatile保证指令不重拍， 因为所有的对象生成(也就是new Instance())一般都会经历三个步骤
不是原子性操作，说明启动多线程的时候可能出现过程混乱，所以想要保证对象原子性,那么就得加上
volatile(防止指令重拍)

1. 向操作系统申请内存（分配内存空间）
2. 执行构造方法，初始化对象
3. 把这个对象指向这个空间

## 单例不安全
因为有反射，所以需要使用Enum类，来创建单例模式

java源码中如果没有任何构造函数，默认编译器会提供无参构造器，
java源码中如果有有参构造哈数，但无无参构造函数，默认编译器不会提供无参构造器
java源码中如果需要使用反射，建议多一个无参构造器
Enum类是一个有参构造器，没有无参构造器
```java
private EnumSin(String s, int i)
        {
            super(s,i);
        }
```


[1]:https://www.bilibili.com/video/BV1B7411L7tE?p=33 